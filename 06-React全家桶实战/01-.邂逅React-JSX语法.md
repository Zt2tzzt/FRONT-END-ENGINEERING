# 认识 React？

- 相信每个做开发的人对它都或多或少有一些印象；
- 这里我们来看一下官方对它的解释：用于**构建用户界面的 JavaScript 库**；

React 在前端处于什么地位？react 官网。

- 目前对于前端开发来说，几乎很少直接使用原生的JavaScript来开发应用程序，而是选择一个JavaScript库（框架）。
	- 在过去的很长时间内，jQuery是被使用最多的JavaScript库；
	- 在过去的一份调查中显示，全球前10,000个访问最高的网站中，有65%使用了jQuery，是当时最受欢迎的JavaScript库；
	- 但是，目前甚至已经处于淘汰的边缘了；

- 而无论是国内外，最流行的其实是三大框架：Vue、React、Angular。

  <img src="NodeAssets/React在前端的地位.jpg" alt="React在前端的地位" style="zoom:80%;" />

React 与其它框架的关系。

- React由Facebook来更新和维护，它是大量优秀程序员的思想结晶：
	- React的流行不仅仅局限于普通开发工程师对它的认可；
	- 大量流行的其他框架借鉴React的思想；
- Vue.js框架设计之初，有很多的灵感来自Angular和React。
	- 包括Vue3很多新的特性，也是借鉴和学习了React；
	- 比如React Hooks是开创性的新功能（也是我们课程的重点）；
	- Vue Composition API学习了React Hooks的思想；
- Flutter的很多灵感都来自React，来自官网的一段话：（SwiftUI呢）
	- 事实上Flutter中的Widget – Element – RenderObject；
	- 对应React的就是JSX – 虚拟DOM – 真实DOM；
- 所以React可以说是前端的先驱者，它总是会引领整个前端的潮流。

 Vue 和 React 如何选择？

- 首先，React和Vue是前端开发人员必须掌握的两个框架。
- 下面的观点是一个目前比较普遍的共识，没有贬低任何框架的意思。
- 大中型公司选择React会较多，灵活和稳定；
- 中小型公司选择Vue会较多，易上手和代码统一；

<img src="NodeAssets/Vue和React在中大型公司中的应用.jpg" alt="Vue和React在中大型公司中的应用" style="zoom:80%;" />


# 如何学习一个新技术栈（如 React）。

<img src="NodeAssets/如何学习一个新技术栈.jpg" alt="如何学习一个新技术栈" style="zoom:80%;" />



学习 React 要具备那些基础？（什么人适合学习）

- 需要掌握前端的核心开发语言：HTML、CSS、JavaScript。
- React本身是JavaScript的要求相对会更高一些，所以也需要掌握一些高级的JavaScript语法，比如ES6以上的语法、this绑定 规则等等；


# React 有哪些技术特点？

- 声明式编程：
	- 声明式编程是目前整个大前端开发的模式：Vue、React、Flutter、SwiftUI；
	- 它允许我们只需要维护自己的状态，当状态改变时，React可以根据最新的状态去渲染我们的UI界面；

	<img src="NodeAssets/声明时编程的模式.jpg" alt="声明时编程的模式" style="zoom:80%;" />

- 组件化开发：
	- 组件化开发页面目前前端的流行趋势，我们会将复杂的界面拆分成一个个小的组件；
	- 如何合理的进行组件的划分和设计也是后面我会讲到的一个重点；

	<img src="NodeAssets/组件化开发模式.jpg" alt="组件化开发模式" style="zoom:80%;" />

- 多平台适配：
	- 2013年，React发布之初主要是开发Web页面；
	- 2015年，Facebook推出了ReactNative，用于开发移动端跨平台；（虽然目前Flutter非常火爆，但是还是有很多公司在使用 ReactNative）；
	- 2017年，Facebook推出ReactVR，用于开发虚拟现实Web应用程序；（VR也会是一个火爆的应用场景）；

	<img src="NodeAssets/React多平台视频.jpg" alt="React多平台视频" style="zoom:100%;" />


# hello World

React 的基本使用

- React16 和 18 有哪些区别？
- 第一步：在界面上通过React显示一个Hello World
	- 注意：这里我们编写React的script代码中，必须添加 type="text/babel"，作用是可以让babel解析jsx的语法
- ReactDOM. createRoot函数：用于创建一个React根，之后渲染的内容会包含在这个根中
	- 参数：将渲染的内容，挂载到哪一个HTML元素上，这里我们已经提定义一个id为root的div
- root.render函数:
	- 参数：要渲染的根组件
- 我们可以通过{}语法来引入外部的变量或者表达式

```html
<body>
	<div id="root"></div>

	<!-- 添加依赖，三个包，使用 CDN 引入，crossorigin的属性，这个属性的目的是为了拿到跨域脚本的错误信息-->
	<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- babel -->
  <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>

	<script type="text/babel">
		// React 18 之前 ReactDOM.render
		// ReactDOM.render(<h2>Hello world</h2>, document.querySelector('#root'))

		// REact18 之后
		const root = ReactDOM.createRoot(document.querySelector('#root'))
		root.render(<h2>Hello World</h2>)

	</script>
</body>
```

# React 的开发依赖有哪些？

- 开发React必须依赖三个库：
	- react：包含react所必须的核心代码
	- react-dom：react渲染在不同平台所需要的核心代码
	- babel：将jsx转换成React代码的工具
- 对于Vue来说，我们只是依赖一个vue.js文件即可，但是react居然要依赖三个包。
	- 其实呢，这三个库是各司其职的，目的就是让每一个库只单纯做自己的事情;
	- 在React的0.14版本之前是没有react-dom这个概念的，所有功能都包含在react里；
- 为什么要进行拆分呢？原因就是react-native。
	- react包中包含了react web和react-native所共同拥有的核心代码。
	- react-dom针对web和native所完成的事情不同：
		- web端：react-dom会将jsx最终渲染成真实的DOM，显示在浏览器中
		- native端：react-dom会将jsx最终渲染成原生的控件（比如Android中的Button，iOS中的UIButton）。


## 什么是 babel

- Babel 是一个工具链，最早用于在旧浏览器或环境中将ES6+代码转成向后兼容的版本。
- 现在主要用于语法转换，源代码转换等。
- Babel本质上是一个编译器。

babel 与 react 的关系是怎样的？

- 默认情况下开发React其实可以不使用babel。
- 但是前提是我们自己使用 React.createElement 来编写源代码，它编写的代码非常的繁琐和可读性差。
- 那么我们就可以直接编写jsx（JavaScript XML）的语法，并且让babel帮助我们转换成React.createElement。

## 依赖的引入方式

- 方式一：直接CDN引入
- 方式二：下载后，添加本地依赖
- 方式三：通过npm管理（后续脚手架再使用）

# Hello react

实现 Hello react 的案例，创建根的做法，

- 将文本定义成变量，并在 jsx 中引用。jsx 中对标识符的引用，都是用 {}
- jsx 中实现事件的监听，监听按钮的点击。
- React 在默认情况下，不会进行重新渲染。

```html
<body>

	<div id="root"></div>

	<!-- 引入下载到本地的依赖 -->
	<script src="../../lib/react.development.js"></script>
	<script src="../../lib/react-dom.development.js"></script>
	<script src="../../lib/babel.min.js"></script>

	<script type="text/babel">
		const root = ReactDOM.createRoot(document.querySelector('#root'))

		// 1.将文本定义成变量
		let msg = 'Hello world'

		// 2.监听按钮的点击
		function onbtnClick() {
			msg = 'Hello React'
			render()
		}

		// 3.封装一个渲染函数
		function render() {
			// 第一个括号表示 render 方法执行，第二个括号表示 jsx 代码块整体
			root.render((
				<div>
					<h2>{ msg }</h2>
					<button onClick={ onbtnClick }>修改文本</button>
				</div>
			))
		}
		render()
	</script>
</body>
```

# React 的组件化开发

- 以上案例中，整个逻辑其实可以看做一个整体，那么我们就可以将其封装成一个组件：

	- 我们知道 root.render 参数是一个HTML元素或者一个组件；
	- 所以我们可以先将之前的业务逻辑封装到一个组件中，然后传入到 ReactDOM.render 函数中的第一个参数；

- 在 React 中，封装一个组件有两种方式，类组件和函数式组件。这里我们先使用类组件。

	1. 定义一个类（类名大写，组件的名称是必须大写的，小写会被认为是HTML元素），继承自React.Component 
	2. 实现当前组件的render函数，render当中返回的jsx内容，就是之后React会帮助我们渲染的内容

```html
<body>
	<div id="root"></div>

	<script src="../../lib/react.development.js"></script>
	<script src="../../lib/react-dom.development.js"></script>
	<script src="../../lib/babel.min.js"></script>

	<script type="text/babel">
		// 使用组件进行代码重构
		class App extends React.Component {
			constructor() {
				super()
				// 组件的状态
				this.state = {
					msg: 'Hello World',
					name: 'zzt',
					age: 18
				}

				// 为某些方法提前绑定好 this
				this.onBtnClick = this.onBtnClick.bind(this)
			}

			onBtnClick() {
				this.setState({
					msg: 'Hello React'
				})
			}

			// 渲染内容 render 方法
			render() {
				return (
					<div>
						<h2>{ this.state.msg }</h2>
						<button onClick={ this.onBtnClick }>修改文本</button>
					</div>
				)
			}
		}

		// 将组件渲染到界面上
		const root = ReactDOM.createRoot(document.querySelector('#root'))
		root.render(<App/>)
	</script>
</body>
```


## 组件化的数据依赖处理。

- 组件化问题一：数据在哪里定义？ 
- 在组件中的数据，我们可以分成两类： 
	- 参与界面更新的数据：当数据变化时，需要更新组件渲染的内容； 
	- 不参与界面更新的数据：当数据变化时，不需要更新组建渲染的内容；
- 参与界面更新的数据我们也可以称之为是参与数据流，这个数据是定义在当前对象的state中 
	- 我们可以通过在构造函数中 this.state = {定义的数据} 
	- 当我们的数据发生变化时，我们可以调用 this.setState 来更新数据，并且通知React进行update操作；在进行update操作时，就会重新调用render函数，并且使用最新的数据，来渲染界面
	
## 组件化的事件绑定处理。

- 组件化问题二：事件绑定中的this 
	- 在类中直接定义一个函数，并且将这个函数绑定到元素的onClick事件上，当前这个函数的this指向的是谁呢？
- 默认情况下是undefined 
	- 很奇怪，居然是undefined； 
	- 因为在正常的DOM操作中，监听点击，监听函数中的this其实是节点对象（比如说是button对象）； 
	- 这次因为React并不是直接渲染成真实的DOM，我们所编写的button只是一个语法糖，它的本质React的Element对象； 
	- 那么在这里发生监听的时候，react在执行函数时并没有绑定this，默认情况下就是一个undefined；为什么呢？
	- ES6 中使用 class，里面的实例方法默认开启严格模式；引用的 babel 库，也会开启严格模式。而在严格模式下，默认绑定会绑定 undefined。
	- jsx 代码会被 babel 编译为一段 js 代码，所以在 jsx 中引用类的实例方法，方法中的 this 默认绑定的是 undefined。
	- `setState` 方法是继承过来的。`this.setState` 做了两件事：
		1. 将state中message值修改掉；
		2. 自动重新执行render函数函数。
- 我们在绑定的函数中，可能想要使用当前对象，比如执行 this.setState 函数，就必须拿到当前对象的this 
	- 我们就需要在传入函数时，给这个函数直接绑定this
	- 类似于下面的写法：`<button onClick={this.changeText.bind(this)}>改变文本</button>`

# 电影列表案例实现。

```html
<body>
	<div id="root"></div>

	<script src="../../lib/react.development.js"></script>
	<script src="../../lib/react-dom.development.js"></script>
	<script src="../../lib/babel.min.js"></script>

	<script type="text/babel">
		// 封装 App 组件
		class App extends React.Component {
			constructor() {
				super()
				this.state = {
					movies: ['星际穿越', '大话西游', '盗梦空间', '黑客帝国']
				}
			}

			render() {
				return (
					<div>
						<h2>电影列表</h2>
						<ul>
							{ this.state.movies.map(item => <li>{ item }</li>) }
						</ul>
					</div>
				)
			}
		}
		
		// 创建 root
		const root = ReactDOM.createRoot(document.querySelector('#root'))
		// 渲染组件
		root.render(<App/>)
	</script>
</body>
```


* 计数器案例的实现。
* 生成 react 渐进式代码片段
* 什么是 jsx？
* 为什么 React 选择了 jsx？（面试）
* jsx 的书写规范。
* jsx 的使用
	- 注释的写法。
	- 嵌入变量作为子元素。
	- 键入表达式。
	- 属性绑定。
		- 动态绑定 class 通常有3种方式
		-	动态绑定 style （内联样式）有很多方式？先了解1种基本方式。


